{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar data_1 = require(\"./helpers/data\");\n\nvar Pagination_1 = __importDefault(require(\"./Pagination\"));\n\nvar PaginationOpts_1 = __importDefault(require(\"./PaginationOpts\"));\n\nvar TableHeader_1 = __importDefault(require(\"./TableHeader\"));\n\nvar TableBody_1 = __importDefault(require(\"./TableBody\"));\n\nvar Filter_1 = __importDefault(require(\"./Filter\"));\n\nvar object_1 = require(\"./helpers/object\");\n\nvar Row_1 = __importDefault(require(\"react-bootstrap/Row\"));\n\nvar Button_1 = __importDefault(require(\"react-bootstrap/Button\"));\n\nvar Table_1 = __importDefault(require(\"react-bootstrap/Table\"));\n\nvar Col_1 = __importDefault(require(\"react-bootstrap/Col\"));\n\nvar ButtonGroup_1 = __importDefault(require(\"react-bootstrap/ButtonGroup\"));\n\nvar FontAwesome_1 = __importDefault(require(\"./modules/FontAwesome\"));\n\nvar TableContext_1 = require(\"./modules/TableContext\");\n/**\n * Datatable lifecycle convenient function.\n * It will be used when we are extending the table.\n **/\n\n\nfunction useDatatableLifecycle(_a) {\n  var initialSort = _a.initialSort,\n      onSort = _a.onSort,\n      onFilter = _a.onFilter,\n      rowsPerPage = _a.rowsPerPage,\n      rowsPerPageOption = _a.rowsPerPageOption,\n      async = _a.async,\n      tableHeaders = _a.tableHeaders,\n      _b = _a.classes,\n      classes = _b === void 0 ? {} : _b,\n      tableBody = _a.tableBody,\n      _c = _a.labels,\n      labels = _c === void 0 ? {} : _c,\n      Components = _a.Components,\n      onRowClick = _a.onRowClick;\n  react_1.useEffect(function () {\n    // If in development, warn if async and onSort/onFilter are both passed.\n    if (process.env.NODE_ENV === 'development') {\n      if (async !== undefined) {\n        // Warn if onSort and/or onFilter is/are also passed down.\n        var str = [];\n\n        if (onSort !== undefined) {\n          str.push('[onSort]');\n        }\n\n        if (onFilter !== undefined) {\n          str.push('[onFilter]');\n        }\n\n        if (str.length > 0) {\n          console.warn(\"You are passing [async] props along with \" + object_1.customJoin(str, ' and ') + \". When [async] is enabled, you should not pass onFilter or onSort.\");\n        } // Warn if all async options are not passed.\n\n\n        str = [];\n\n        if (async.onFilter === undefined) {\n          str.push('[async.onFilter]');\n        }\n\n        if (async.onSort === undefined) {\n          str.push('[async.onSort]');\n        }\n\n        if (async.onPaginate === undefined) {\n          str.push('[async.onPaginate]');\n        }\n\n        if (str.length > 0) {\n          console.warn(\"These async props are missing: \" + object_1.customJoin(str, ', ', 'and '));\n        }\n      }\n    }\n  }, []);\n\n  var _d = react_1.useState(function () {\n    var sortObj = initialSort || {};\n    var filterable = async !== undefined && async.onFilter !== undefined;\n    var defaultSort = {};\n    tableHeaders.forEach(function (header) {\n      if (header.prop === sortObj.prop) {\n        if (header.sortable) {\n          defaultSort = {\n            isAscending: true,\n            prop: header.prop\n          };\n        }\n      }\n\n      if (header.filterable && async === undefined && !filterable) {\n        filterable = true;\n      }\n    }); // Define initial state.\n\n    return {\n      sortedProp: defaultSort,\n      filterable: filterable,\n      rowsPerPage: rowsPerPage,\n      currentPage: 1,\n      filterText: ''\n    };\n  }),\n      state = _d[0],\n      setState = _d[1];\n\n  react_1.useEffect(function () {\n    // Resets the table if the data passed down is different.\n    if (tableBody !== undefined) {\n      setState(function (oldState) {\n        return __assign(__assign({}, oldState), {\n          filterText: '',\n          currentPage: 1,\n          rowsPerPage: rowsPerPage\n        });\n      });\n    }\n  }, [tableBody, rowsPerPage]);\n\n  function onChangeFilter(text) {\n    if (async && async.onFilter) {\n      async.onFilter(text);\n    } else {\n      setState(function (oldState) {\n        return __assign(__assign({}, oldState), {\n          filterText: text,\n          currentPage: 1\n        });\n      });\n    }\n  }\n\n  function onPageNavigate(nextPage) {\n    if (async && async.onPaginate) {\n      async.onPaginate(nextPage);\n    } else {\n      setState(function (oldState) {\n        return __assign(__assign({}, oldState), {\n          currentPage: nextPage\n        });\n      });\n    }\n  }\n\n  function onRowsPerPageChange(numOfPage) {\n    if (async && async.onRowsPerPageChange) {\n      async.onRowsPerPageChange(numOfPage);\n    } else {\n      setState(function (oldState) {\n        return __assign(__assign({}, oldState), {\n          rowsPerPage: numOfPage,\n          currentPage: 1\n        });\n      });\n    }\n  }\n\n  function onSortChange(nextProp) {\n    if (async && async.onSort) {\n      async.onSort(nextProp);\n    } else {\n      var nextSort_1 = state.sortedProp;\n\n      if (nextProp !== state.sortedProp.prop) {\n        nextSort_1.prop = nextProp;\n        nextSort_1.isAscending = true;\n      } else {\n        nextSort_1.isAscending = !state.sortedProp.isAscending;\n      }\n\n      setState(function (oldState) {\n        return __assign(__assign({}, oldState), {\n          sortedProp: nextSort_1\n        });\n      });\n    }\n  }\n\n  var data = tableBody;\n  var maxPage;\n\n  if (async === undefined) {\n    data = data_1.filterData(tableBody, tableHeaders, state.filterText, onFilter);\n    data = data_1.sortData(data, state.sortedProp, onSort);\n\n    if (state.rowsPerPage) {\n      // Pagination needs.\n      data = data_1.paginateData(data, state.currentPage, state.rowsPerPage);\n      maxPage = Math.ceil(tableBody.length / state.rowsPerPage);\n    }\n  } else {\n    maxPage = async.maxPage;\n  }\n\n  var tableClass = object_1.makeClasses(\"table-datatable__root\", classes.table); // Default components.\n  // If context has keys, then use context. Instead, use Components props.\n\n  var context = TableContext_1.useComponentProvider();\n  var passedComponents = Object.keys(context).length > 0 ? context : Components;\n  var usedComponents = {\n    // Global.\n    Row: Row_1.default,\n    Col: Col_1.default,\n    Button: Button_1.default,\n    // Table.\n    Table: Table_1.default,\n    TableHead: 'thead',\n    TableBody: 'tbody',\n    TableRow: 'tr',\n    TableCell: 'td',\n    // Filter.\n    FilterGroup: undefined,\n    // Pagination.\n    ButtonGroup: ButtonGroup_1.default,\n    // Pagination options.\n    PaginationOptsGroup: undefined,\n    // ICons.\n    SortIcon: FontAwesome_1.default\n  };\n\n  if (passedComponents !== undefined) {\n    if (typeof passedComponents === 'object') {\n      for (var key in passedComponents) {\n        // Replace usedComponent fields with the passedComponents fields.\n        usedComponents[key] = passedComponents[key];\n      }\n    }\n  }\n\n  return {\n    data: data,\n    tableHeaders: tableHeaders,\n    onChangeFilter: onChangeFilter,\n    onPageNavigate: onPageNavigate,\n    classes: classes,\n    onRowsPerPageChange: onRowsPerPageChange,\n    onSortChange: onSortChange,\n    tableClass: tableClass,\n    labels: labels,\n    rowsPerPageOption: rowsPerPageOption,\n    Components: usedComponents,\n    onRowClick: onRowClick,\n    // States.\n    filterable: state.filterable,\n    filterText: async ? async.filterText : state.filterText,\n    rowsPerPage: async ? async.rowsPerPage : state.rowsPerPage,\n    currentPage: async ? async.currentPage : state.currentPage,\n    sortedProp: async ? async.sortedProp : state.sortedProp,\n    maxPage: maxPage\n  };\n}\n\nexports.useDatatableLifecycle = useDatatableLifecycle;\n/** Datatable Component. */\n\nfunction Datatable(props) {\n  var _a = useDatatableLifecycle(props),\n      data = _a.data,\n      rowsPerPageOption = _a.rowsPerPageOption,\n      tableHeaders = _a.tableHeaders,\n      onChangeFilter = _a.onChangeFilter,\n      onPageNavigate = _a.onPageNavigate,\n      classes = _a.classes,\n      onRowsPerPageChange = _a.onRowsPerPageChange,\n      onSortChange = _a.onSortChange,\n      tableClass = _a.tableClass,\n      labels = _a.labels,\n      filterable = _a.filterable,\n      filterText = _a.filterText,\n      rowsPerPage = _a.rowsPerPage,\n      currentPage = _a.currentPage,\n      sortedProp = _a.sortedProp,\n      maxPage = _a.maxPage,\n      Components = _a.Components,\n      onRowClick = _a.onRowClick;\n\n  return react_1.default.createElement(react_1.default.Fragment, null, react_1.default.createElement(Components.Row, {\n    className: object_1.makeClasses('controlRow__root', classes.controlRow)\n  }, react_1.default.createElement(Components.Col, {\n    xs: 12,\n    sm: 4,\n    className: classes.filterCol\n  }, react_1.default.createElement(Filter_1.default, {\n    filterable: filterable,\n    classes: classes,\n    placeholder: labels.filterPlaceholder,\n    onChangeFilter: onChangeFilter,\n    filterText: filterText,\n    CustomFilterGroup: Components.FilterGroup\n  })), react_1.default.createElement(Components.Col, {\n    xs: 12,\n    sm: 2,\n    className: classes.paginationOptsCol\n  }, react_1.default.createElement(PaginationOpts_1.default, {\n    classes: classes,\n    labels: labels,\n    onRowsPerPageChange: onRowsPerPageChange,\n    rowsPerPage: rowsPerPage,\n    rowsPerPageOption: rowsPerPageOption,\n    CustomPaginationOptsGroup: Components.PaginationOptsGroup\n  })), react_1.default.createElement(Components.Col, {\n    xs: 12,\n    sm: 6,\n    className: object_1.makeClasses('text-right', classes.paginationCol)\n  }, react_1.default.createElement(Pagination_1.default, {\n    maxPage: maxPage,\n    classes: classes,\n    rowsPerPage: rowsPerPage,\n    currentPage: currentPage,\n    onPageNavigate: onPageNavigate,\n    labels: labels,\n    components: {\n      Button: Components.Button,\n      ButtonGroup: Components.ButtonGroup\n    }\n  }))), react_1.default.createElement(Components.Row, null, react_1.default.createElement(Components.Col, {\n    xs: 12\n  }, react_1.default.createElement(Table_1.default, {\n    className: tableClass\n  }, react_1.default.createElement(TableHeader_1.default, {\n    classes: classes,\n    tableHeaders: tableHeaders,\n    sortedProp: sortedProp,\n    onSortChange: onSortChange,\n    components: {\n      TableHead: Components.TableHead,\n      TableCell: Components.TableCell,\n      TableRow: Components.TableRow\n    }\n  }), react_1.default.createElement(TableBody_1.default, {\n    classes: classes,\n    tableHeaders: tableHeaders,\n    labels: labels,\n    data: data,\n    components: {\n      TableBody: Components.TableBody,\n      TableCell: Components.TableCell,\n      TableRow: Components.TableRow\n    },\n    onRowClick: onRowClick\n  })))));\n} // Only update if rowsPerPage, rowsPerPageOption, and tableBody changes.\n\n\nexports.default = react_1.default.memo(Datatable, object_1.shouldTableUpdate);","map":null,"metadata":{},"sourceType":"script"}